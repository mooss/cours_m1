#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \newcommand{\eqdot}{\dot{=}}
#+LATEX_HEADER: \newcommand{\sederiveen}{\xRightarrow{*}}

* Projet compilo
** Définitions
 - GPL :: Grammaire Petit Langage
 - Scanner :: analyse lexicale
 - Analyseur :: autres analyses (syntaxique et semantique)
** Schémas
#+BEGIN_SRC ditaa :file projetcompilo.png :cmdline -Eo




                   +-----------+                                           +----------+
                   |           |                                           |          |
                   | G0        |                                           | GPL      |
                   |           |                                           |          |
                   +-----+-----+                                           +----+-----+
                         |                                                      |
                         v                                                      v
                  +---------------+----------------+             +--------------------+------------------+
                  |               |                |             |                    |                  |
                  |               | Arbre          |             |                    |                  |
                  |               | dépendance (A) |             |                    |                  |
                  | Scan G0       |                |             | Scan GPL           | A[G] ... A[N]    |        +----------------+
                  | Analyseurs    |                |             | Analyseurs         |                  |        |                |
                  |               +----------------+             |                    +------------------+        |  Gen P-code    |
                  |                                |             |                                       |        |                |
                  |                                |             |                                       |        |      +         |
                  |               +----------------+             |                                       +------->|                |
                  |               |                |             |                                       |        |  Interpreteur  |
                  |               | Actions G0     +------------>|                                       |        |                |
       +--------->|               |                |             |                    +------------------+        +----------------+
       |          |               |                |             |                    |                  |
       |          +---------------+----------------+             |                    | Actions GPL      |
  +----+-----+                                        +--------->|                    |                  |
  |          |                                        |          |                    |                  |
  | GPL      |<---------+                             |     +--->|                    |                  |
  |          |          |                             |     |    +--------------------+------------------+
  +----------+          |                             |     |
        +---------------+-------------+               |     +-------------------------------------+
        |                             |               |                                           |
  +-----+-------------+   +-----------+---------+     +--------------+                            |
  |                   |   |                     |                    |                            |
  | Grammaire Java    |   | Grammaire cpp       |            +-------+----------+        +--------+---------+
  |                   |   |                     |            |                  |        |                  |
  +-------------------+   +---------------------+            | Programme        |        | Programme        |
                                                             | Java             |        | cpp              |
                                                             |                  |        |                  |
                                                             +------------------+        +------------------+
#+END_SRC

#+RESULTS:
[[file:projetcompilo.png]]

#+CAPTION: Projet Compilo
#+NAME:   fig:Projet Compilo
[[./compilo2.jpg]]


#+BEGIN_SRC dot :file archicompilo.png :cmdline -Kdot -Tpng -Gdpi=300
  digraph {
     rankdir=LR
     node[shape=record]
     ansy [label="<a>Analyse|<s>Synthese"]
     an [label="<sc>Scan|<pa>Parse|<asem>Analyse\nSemantique"]
     gr [label="Grammaire"]
     re [label="Reguliere"]
     cf [label="Context Free"]
     sy [label="Generation|<op>Optimisation|Interpretation"]

     ansy:an -> an -> gr -> re,cf
     ansy:sy -> sy
  }
#+END_SRC

#+BEGIN_SRC dot :file Atree.png :cmdline -Kdot -Tpng -Gdpi=300

digraph G {
A [shape=Mdiamond];
subgraph clusterA {
S [shape=square];
N [shape=square];
E [shape=square];
T [shape=square];
F [shape=square];

}

subgraph clusterS {
    edge [dir=none]
    node [shape=none, style=none];
    ls1  [ label = "." ];
    ls21 [ label = "*" ];
    ls22 [ label = ";" ];
    ls31 [ label = "." ];
    ls41 [ label = "." ];
    ls42 [ label = "," ];
    ls51 [ label = "." ];
    ls52 [ label = "E" ];
    ls61 [ label = "N" ];
    ls62 [ label = "'->'" ];

    ls1  -> { ls21 ls22 };
    ls21 -> { ls31 };
    ls31 -> { ls41 ls42 };
    ls41 -> { ls51 ls52 };
    ls51 -> { ls61 ls62};
}

subgraph clusterN {
    node [shape=none, style=none];
    ln [ label="IDNTER"];
}

subgraph clusterE {
    edge [dir=none]
    node [shape=none, style=none];
    le1  [ label = "." ];
    le21 [ label = "T" ];
    le22 [ label = "*" ];
    le31 [ label = "." ];
    le41 [ label = "'+'" ];
    le42 [ label = "T" ];

    le1  -> { le21 le22 };
    le22 -> { le31 };
    le31 -> { le41 le42 };
}

subgraph clusterT {
    edge [dir=none]
    node [shape=none, style=none];
    lt1  [ label = "." ];
    lt21 [ label = "F" ];
    lt22 [ label = "*" ];
    lt31 [ label = "." ];
    lt41 [ label = "'.'" ];
    lt42 [ label = "F" ];

    lt1  -> { lt21 lt22 };
    lt22 -> { lt31 };
    lt31 -> { lt41 lt42 };
}

subgraph clusterf {
    edge [dir=none]
    node [shape=none, style=none];
    lf1  [ label = "+" ];
    lf21  [ label = "+" ];
    lf22  [ label = "." ];
    lf31  [ label = "+" ];
    lf32  [ label = "." ];
    lf33  [ label = "E" ];
    lf34  [ label = "'/)'" ];
    lf41  [ label = "+" ];
    lf42  [ label = "." ];
    lf44  [ label = "E" ];
    lf43  [ label = "']'" ];
    lf45  [ label = "." ];
    lf51  [ label = "'IDNTER'" ];
    lf52  [ label = "'ELTER'" ];
    lf53  [ label = "E" ];
    lf54  [ label = "')'" ];
    lf55  [ label = "." ];
    lf56  [ label = "'(/'" ];
    lf61  [ label = "." ];
    lf62  [ label = "'['" ];
    lf71  [ label = "'('" ];

    lf1 -> { lf21 lf22 };
    lf21 -> {lf31 lf32};
    lf22 -> {lf33 lf34};
    lf31 -> {lf41 lf42};
    lf32 -> {lf43 lf44};
    lf33 -> lf45 -> lf56;
    lf41 -> {lf51 lf52};
    lf42 -> {lf53 lf54};
    lf44 -> lf55 -> lf62;
    lf53 -> lf61;
    lf61 -> lf71;

}

	S -> ls1;
  N -> ln;
  E -> le1;
  T -> lt1;
  F -> lf1;


}

#+END_SRC

#+RESULTS:
[[file:archicompilo.png]]

** Construction  de la grammaire G0 (il doit manquer pas mal de trucs)

*** Notation B.N.F.
 - $::= \iff \to$
 - $[X] \iff X.X.X...X \text{(n fois)}, n \geq 0$
 - $x \iff \cdot$

*** Regle 1
$$S \to [N.'\to' . E . ','].';',$$
 - $\text{concatenation} \iff \cdot$
 - pour differencier les terminaux et les non terminaux, on met les terminaux entre guillemets

*** Regle 2
$$N \to 'INDTER',$$

*** Regle 3
$$ E \to R.['+'.T],$$

*** Regle 4
$$ T \to F.['.'.F],$$

*** Regle 5
$$F \to 'INDTER' + 'ELTER' + '('.E.')' + '['.E.']' + '(/'.E.'/),;$$

** Structure de donnees
Syntaxe maison...

#+BEGIN_EXAMPLE
Type Atomtype = (Terminal, Non-Terminal);
     Operation = (Conc, Union, Star, UN, Atom);
PTR = \uparrow Node

Node = Enregistrement
       case operation of
       Conc: (left, right : PTR);
       Union: (left, right : PTR);
       Star: (stare: PTR);
       UN: (UNE : PTR);
       ATOM: (COD, Act : int ; AType: Atomtype);
       EndEnregistrement

A: Array [1..5] of PTR:
#+END_EXAMPLE

** Construction des 5 Arbres

#+BEGIN_EXAMPLE
Fonction GenConc(P1, P2: PTR) : PTR;
  var P:PTR
debut
  New(P, Conc);
  P\uparrow.left := P1;
  P\uparrow.right := P2;
  P\uparrow.class := Conc;
  Conc := P;
fin

GenUnion,
GenStar, //0 ou n fois
GenUn,//0 ou une fois
GenAtom

A[S] :=
  GenConc(
    GenStar(
      GenConc(
        GenConc(
          GenConc(GenAtom('N', ∅, NonTerminal)),
          GenAtom('->', , Terminal)
        ),
        GenAtom('E', ∅, )
      ),
      GenAtom(',', , Terminal)
    ),
    GenAtom(';', , Terminal)
  );

#+END_EXAMPLE




* Grammaires LL(k)

$k$ est une mesure de l'ambiguite.
Represente le nombre de caracteres qu'il est necessaire de regarder pour determiner quelle regle utiliser.
Bien entendu, les regles LL(1) sont preferables.

** Premier(N)
 - Si $N \rightarrow A\dots$ alors $Premier(N)=Premier(A)$
 - Si $N \rightarrow c\dots$ alors $Premier(N)=\{c\}$
 - Si $N \rightarrow A . B \dots{} \wedge A \Rightarrow \epsilon$ alors $Premier(N)=Premier(B)$

Avec "\Rightarrow" signifiant "se derivant en".

Il ne s'agit pas d'appliquer une regle a chaque fois, mais plutot d'appliquer toutes les regles possibles.

** Suivants
 - Si $A \rightarrow \dots Nc \dots$ alors $Suiv(N)=\{c\}$
 - Si $A \rightarrow \dots NB \dots$ alors $Suiv(N)=Prem(B)$
 - Si $A \rightarrow N\dots$ alors $Suiv(N)=Suiv(A)$

** Grammaire LL(1)
 - si $A \rightarrow \alpha{}_1 / \alpha{}_2 / \dots / \alpha{}_n$ alors
   $$Prem(\alpha_i) \cap Prem(\alpha_j) = \Phi,  \forall i \ne j$$
 - si $A \Rightarrow \epsilon$ on doit avoir $Prem(A) \cap Suiv(A) = \Phi$

Si une regle ne possede qu'une derivation, la regle 1 ne s'applique pas.
Si une regle ne possede pas de suiv, la regle 2 ne s'applique pas.


* Opérateurs $\eqdot$, $\gtrdot$, et $\lessdot$

 - $X \eqdot Y$ si
\begin{equation*}
A \rightarrow \dots{} X.Y \dots{} \in \mathcal{P}
\end{equation*}
 - $X \lessdot Y$ si
\begin{equation*}
  \begin{split}
    & A \rightarrow \dots{} X . Q \dots{} \in \mathcal{P} \\
    & \text{et } Q \sederiveen Y$
  \end{split}
\end{equation*}
 - $X \gtrdot Y$ si
\begin{equation*}
  \begin{split}
    & A \eqdot Y\\
    & \text{et } A \sederiveen X
  \end{split}
\end{equation*}


On peut remplir le tableau SR à partir des relations $\eqdot$ , $\gtrdot$ et $\lessdot$ :
 - (ligne $\eqdot$ colonne) et (ligne $\lessdot$ colonne) se traduisent en (ligne Shift colonne)
 - (ligne $\gtrdot$ colonne) se traduit en (ligne Reduce colonne)

* Types des grammaires
 - 0 :: type c
 - 1 :: type context sensitive CS
        $\gamma \rightarrow \beta$ avec $\norm{\gamma} \leq \norm{\beta}$
 - 2 :: type context free CF
        $A \rightarrow B$ avec $A \in V_N, B \in V^+$
 - 3 :: type reguliere
        \begin{cases}
          A \rightarrow aB\\
          A \rightarrow a\\
        \end{cases}
        ou
        \begin{cases}
          A \rightarrow Ba\\
          A \rightarrow a
        \end{cases}

$$L(G) = \{x \in V_{T}^* / S \Rightarrow x\}$$

l'intersection de deux languages de type x n'est pas forcement de type x.
